%template code

这里只是记一下 C 里有，但是 Go 跟 C 很不一样的地方，大都是从 [[A Tour of Go|A Tour of Go]] 看来的

可以从下面几个链接比较系统地学习:

* [[http://go-tour-zh.appspot.com/|Go 指南]]  中文版的 go-tour
* [[https://gobyexample.com|Go by Example]]
* [[https://github.com/astaxie/build-web-application-with-golang|Go Web 编程]]
* [[https://github.com/qyuhen/book|Go 学习笔记]]  这还有其他两本 C 和 Python 的学习笔记

----

=== 函数 ===

声明语法
{{{
func 函数名(没有参数，或多个参数) 任意数量的返回值 {

}
}}}

连续的参数类型相同时，可以省略前面的类型，只写最后一个类型
{{{class="go"
func add(x, y int) int {
    return x + y
}
}}}

命名返回值
{{{class="go"
package main

import "fmt"

func split(sum int) (x, y int) {
    x = sum * 4 / 9;
    y = sum -x
    return
}

func main() {
    fmt.Println(split(17))
}
}}}

上面的函数 `split` 返回了 x, y 两个“结果参数”(7, 10)

=== 变量 ===
定义

{{{class="go"
var i, j int = 1, 2
var c, python, java = true, false, "no!"
a, b, c := true, false, "no!"
const birth_year = 1989
}}}

类型在变量名后面，定义时进行初始化，可以省略变量类型, `:=` 可以替代 `var`, 不能使用在函数外

常量用 const 关键字，不能用 `:=` 定义

变量的类型转换必须是显式转换。

=== 流程控制 ===

`for` 和 `if` 语句除了没有'()', 其他基本跟 C 类似。

`for` 跟 C 一样，前置和后置语句都可以为空，不一样的是，当前置或后置语句为空时，分号 ';' 可以省略。
前置、后置语句都为空，跟 C 里面的 `while` 就一样了，如果又省略了循环条件，只剩下一个 `for` ，就是死循环
{{{class="go"
for {
// 死循环
}
}}}

可以在条件之前加一个语句，这个语句定义的变量可以在当前的 `if` (包括其对应的 `else`, 如果有的话) 或 `for` 范围之内使用

{{{class="go"
package main

import (
    "fmt"
    "math"
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v < lim {
        return v
    } else {
        fmt.Printf("%g >= %g\n", v, lim)
    }
    // 这里开始就不能使用 v 了
    return lim
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}
}}}

{{{class="go"
package main

import (
    "fmt"
)

func Sqrt(x float64) float64 {
    z := 1.0
    for i := 0; i < 10; i++ {
        z = z - (z * z - x) / (2 * z)
    }
    return z
}

func main() {
    fmt.Println(Sqrt(2))
}
}}}

==== switch ====
`switch` 后面不必是整数，也可以什么都没有。可以替代 C 中 `if  -  else if  -  else` 这样的语句。

{{{class="go"
func main() {
    // 这里的条件是字符串
    fmt.Print("Go runs on ")
    switch os := runtime.GOOS; os {
    case "darwin":
        fmt.Println("OS X.")
    case "linux":
        fmt.Println("Linux.")
    default:
        // freebsd, openbsd,
        // plan9, windows...
        fmt.Printf("%s.", os)
    }
}
}}}

执行过程从上到下，直到匹配的项，不在继续往下执行。
{{{class="go"
i := 0
switch i {
    case 0:
        // ...
    case f():
        // ...
}
// 不会执行 f()
}}}

默认每个 `case` 结尾都相当与带了 C 语言中的 `break`, 也就时执行完这个 `case` 里的代码就跳出 `switch` 块。除非在结尾加上 `fallthrough`, 这样会继续执行下面 `case` 中的代码

{{{class="go"
integer := 6
switch integer {
    case 4:
    fmt.Println("The integer was <= 4")
    fallthrough
    case 5:
    fmt.Println("The integer was <= 5")
    fallthrough
    case 6:
    fmt.Println("The integer was <= 6")
    fallthrough
    case 7:
    fmt.Println("The integer was <= 7")
    fallthrough
    case 8:
    fmt.Println("The integer was <= 8")
    fallthrough
    default:
    fmt.Println("default case")
}
}}}
输出
{{{
The integer was <= 6
The integer was <= 7
The integer was <= 8
default case
}}}

=== 结构体 ===
_TODO_

----

其余内容基本上是 Go 自己有的了

